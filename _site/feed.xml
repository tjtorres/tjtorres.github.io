<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Random Projections</title>
    <description>This blog details my data science and data visualization projects and thoughts.</description>
    <link>localhost:4000/</link>
    <atom:link href="localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 23 Mar 2015 00:31:53 -0700</pubDate>
    <lastBuildDate>Mon, 23 Mar 2015 00:31:53 -0700</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Inside SentiMap.us: Part 1</title>
        <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is the first in a series of planned posts describing the building of my web app project &lt;a href=&quot;http://sentimap.us&quot;&gt;SentiMap.us&lt;/a&gt;. The basic premise behind SentiMap is to plot localized trends in mood via realtime sentiment analysis of a geotagged Twitter stream. This post will focus mainly on the backend sentiment analysis portion of the project and take you through streaming tweets, feature extraction, and classification.&lt;/p&gt;

&lt;p&gt;Without getting too far into the details just yet, the main functionality behind the sentiment classification, in this case, comes from vectorizing tweets via Word2Vec to construct tweet feature vectors and then training a random forest classifier on a &lt;a href=&quot;http://help.sentiment140.com/for-students&quot;&gt;pre-classified tweet corpus&lt;/a&gt;. We will cover each of these topics in greater detail later, but for now let’s focus on the setup.&lt;/p&gt;

&lt;p&gt;The entirety of the coding for the first post will be in python, and will use the following libraries:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tweepy (Python library for dealing with the Twitter API)&lt;/li&gt;
  &lt;li&gt;NLTK (Natural Language Toolkit used for stopwords)&lt;/li&gt;
  &lt;li&gt;gensim (Python library containing Word2Vec algorithm)&lt;/li&gt;
  &lt;li&gt;Pandas (for managing the Tweet training corpus)&lt;/li&gt;
  &lt;li&gt;Scikit-Learn (providing machine learning functionality)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;pip install tweepy nltk gensim pandas sklearn
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Note that in order to use NLTK’s stop word corpus you must first download it via&lt;/p&gt;

&lt;div class=&quot;highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color:#B44;font-weight:bold&quot;&gt;nltk&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;nltk.download()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;With that out of the way, the basic flow follows two main lines:&lt;/p&gt;

&lt;h4 id=&quot;training-the-classifier&quot;&gt;Training the Classifier&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Load the GoogleNews pre-trained Word2Vec vectors.&lt;/li&gt;
  &lt;li&gt;Import and format/clean the Sentiment140 Twitter Corpus.&lt;/li&gt;
  &lt;li&gt;Vectorize the training data tweets.&lt;/li&gt;
  &lt;li&gt;Train a classifier on the cleaned corpus data (I chose a Random Forest).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;prediciting-tweet-sentiment-from-stream&quot;&gt;Prediciting Tweet Sentiment From Stream&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Grab JSON formatted output from the Stream endpoint of the Twitter API&lt;/li&gt;
  &lt;li&gt;Strip/clean tweet text.&lt;/li&gt;
  &lt;li&gt;Vectorize cleaned tweet.&lt;/li&gt;
  &lt;li&gt;Predict sentiment and store data in database.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;representing-words-as-vectors&quot;&gt;Representing Words as Vectors&lt;/h2&gt;

&lt;p&gt;We’ll start out by training a machine learning classifier to predict tweet sentiment. The general methodology behind any classification scheme is to take a dataset and transform each data point into a vector that, we hope, represents its most salient features with respect to the task at hand. This process of feature extraction can be nearly trivial for some applications, but in general it represents a substantive obstacle with no unique solution.&lt;/p&gt;

&lt;p&gt;In the case of natural language processing (NLP), the process of feature extraction for use in sentiment analysis is particularly ill-defined. When we, as people, parse a sentence or phrase we can draw upon years of past experience and contextual clues from countless interactions with language to determine whether said phrase is generally positive, negative, or neutral. For instance, most people would generally decide that the sentence “He is not the brightest crayon in the box.” is reasonably negative. However, without the idiomatic context, the phrase itself might be viewed as merely neutral.&lt;/p&gt;

&lt;p&gt;Additionally, taking this lack of context to the extreme we might consider the same phrase where even the order of words (that is the contextual clues in the the text itself) were beyond our knowledge. Or perhaps in it’s ultimate manifestation, the ordering of letters and characters. It’s easy to see the difficulty in deciding anything, other than perhaps letter frequency, about a phrase that has been deconstructed so completely. Yet this is somewhat akin to the world that machines inhabit, having no previous knowledge of language context beyond syntactic rules for translating code documents into binary.&lt;/p&gt;

&lt;p&gt;Thus, while there are certainly more naive approaches to constructing vector representations of documents, the big challenge is then to construct systems which simulate the process of learning contextual knowledge. To that end, we will focus on a system of algorithms, called Word2Vec, designed to extract context clues for specific words via the analysis of massive datasets of text.&lt;/p&gt;

&lt;p&gt;As much as I’d love to speak a bit about how Word2Vec works (perhaps a future blog post) in gritty technical detail, for now I will point you to a &lt;a href=&quot;http://technology.stitchfix.com/blog/2015/03/11/word-is-worth-a-thousand-vectors/&quot;&gt;blog post written by a friend of mine&lt;/a&gt; which is quite accessible to the lay-person, but contains a large number of technical links at the bottom for those who wish to delve further. Suffice it to say here that Word2Vec “learns” N-dimensional vector representations of words by analyzing and associating words that are less than a certain distance from them in the corpus of training text. At the end of the day we want two words to have vectors that are “close” to each other when it is probabilistically favorable for them to be near each other in a system of documents. For example, a decent metric for determining the “closeness” of vectors is the angle between them which can be easily obtained through use of the inner (or dot) product. Consequently, one might expect that “lion” and “giraffe” are often mentioned within close proximity to one another and thus the angle between their vector representations should be close to zero.&lt;/p&gt;

&lt;p&gt;Given the amount of text needed to train these models, it is often advantageous to use large corpuses of words with their pre-trained vectors representations. As the original implementation of Word2Vec was invented by a Google engineer, the codebase, as well as &lt;a href=&quot;https://drive.google.com/file/d/0B7XkCwpI5KDYNlNUTTlSS21pQmM/edit?usp=sharing&quot;&gt;pre-trained vector sets&lt;/a&gt; can be found on their site &lt;a href=&quot;https://code.google.com/p/word2vec/&quot;&gt;here&lt;/a&gt;. For this example we will use their vectors that have been trained on GoogleNews stories.&lt;/p&gt;

&lt;p&gt;Since our vectors are pre-trained we will just need to load the binary file into gensim’s Word2Vec implementation. Vectors for given words are then easily accessible by using the word strings as keys on our model instance. Then we will construct a function to take a string with only letters and whitespace and remove common words of little contextual meaning, called stop words, then output a vector based on the average of the set of words in the string.&lt;/p&gt;

&lt;div class=&quot;highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color:#B44;font-weight:bold&quot;&gt;gensim&lt;/span&gt; &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;as&lt;/span&gt; gs

model = gs.models.Word2Vec.load_word2vec_format(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;./GoogleNews-vectors-negative300.bin&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&#39;&lt;/span&gt;&lt;/span&gt;, binary=&lt;span style=&quot;color:#069&quot;&gt;True&lt;/span&gt;)

&lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color:#06B;font-weight:bold&quot;&gt;phrase2vec&lt;/span&gt;(phrase):
    phrase = phrase.lower().split()
    phrase_fil = [w &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;for&lt;/span&gt; w &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;in&lt;/span&gt; phrase &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;not&lt;/span&gt; w &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;in&lt;/span&gt; stop_set]
    size = &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;
    vec = np.zeros(&lt;span style=&quot;color:#00D&quot;&gt;300&lt;/span&gt;)
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;for&lt;/span&gt; word &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;in&lt;/span&gt; phrase_fil:
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;try&lt;/span&gt;:
            vec= np.add(vec,model[word])
            size+=&lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
        &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;except&lt;/span&gt;:
            &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;pass&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;if&lt;/span&gt; size==&lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;:
        size=&lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
    &lt;span style=&quot;color:#080;font-weight:bold&quot;&gt;return&lt;/span&gt; np.divide(vec,size)

&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 23 Mar 2015 01:00:00 -0700</pubDate>
        <link>localhost:4000/2015/03/23/sentimap/</link>
        <guid isPermaLink="true">localhost:4000/2015/03/23/sentimap/</guid>
        
        
      </item>
    
  </channel>
</rss>
